## Руководство к проекту

Работа представленна в ноутбуке: experiments_learning.ipynb

### Данные

1. Данные нужно собирать чистые, то есть в них не должно быть много ошибок: выполнение неправильного жеста, заучивание пользователя протокола. Рекомендуем добавить геймификацию, как в игре Just Dance, когда пользователь будет заранее видеть следующий жест. Так можно будет избежать две упомянутые проблемы.

2. Данные важно правильно размечать, поэтому были созданы классы BasePeakMarker и BaseMarker, задача которых бороться с выбросами и находить переходы жестов. Познакомиться с ними подробнее можно в папке motorica/emg8/markers.py. 

3. При работе с файлами была разработана функция read_emg8(), которая
    - Осуществляет чтение файла с данными измерений монтажа .emg8.

    - Перенумеровывает классы жестов в порядке их следования по протоколу монтажа.

    - Добавляет в возвращаемый датафрейм признак `sync_col_name`, представляющий собой порядковый номер жеста в монтаже.

    - Находит циклы протокола и маркирует их признаком `group_col_name`.

    Подробнее в файле: motorica/emg8/pipeline.py. 

4. Подготовлены интерактивные визуализации получившихся разметок.

### Подготовка данных для обучения LSTM

1. Т.к. чем больше данных, тем лучше, то мы объединили все файлы пилота, разбивая данные на тренировочные и тестовые. Тестовые файлы представляют собой отрезанный последний цикл каждого файла.

2. Создание последовательностей для подачи в модель происходило с помощью функции create_sequences(). Также Х и у были приведены в формат (samples, timesteps, features) и one-hot encoding соответсвенно.

### Построение и валидация модели

1. Функция для создания модели create_lstm_model(), в которой можно выбирать слои Bidirectional, GRU, LSTM. Экспериментальным путём выяснилось, что архитектура модели не должна быть слишком сложной, иначе теряются общие зависимости.

2. Оптимизация и подбор гиперпараметров осуществлялся с помощью функции optimize_lstm(), которая меняла timesteps, n_units, dropout_rate, learning_rate.

3. Дальше найдя лучшие параметры, подготавливались данные с учётом лучших timesteps и создавалась новая модель.

4. Визуализация обучения и функции потерь также представленны. В результате работы модели была достигнута точность в 90% на валидационной выборке. 

### Предсказание

Предсказывалась вероятность каждого из 8 представленных классов, а позже отбиралась наивероятнейшая.

### Инференс

Предобработка данных в реальном времени предоставленна в функции preprocessing(), предсказание вероятности классов реализовано в функции inference(), а определение самого класса жеста в postprocessing().

Также приведен пример инференса для поступающих сигналов каждые 40 мс.

# Итоги и выводы: 

В результате работы была решена задача классификации жестов руки на основе поступающих сигналов.
